---
layout:     post
title:      " \"Hello Git\""
subtitle:   Learn git in under 10 mins
date:       2019-01-01 12:00:00
author:     "tengshiquan"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - git
---


# 	Git

整理3篇快速上手教程



## 10 Minutes

https://www.freecodecamp.org/news/learn-the-basics-of-git-in-under-10-minutes-da548267cc91/
![img](https://cdn-media-1.freecodecamp.org/images/1*iL2J8k4ygQlg3xriKGimbQ.png)

- `git add` is a command used to add a file that is in the working directory to the staging area.
- `git commit` is a command used to add all files that are staged to the local repository.
- `git push` is a command used to add all committed files in the local repository to the remote repository. So in the remote repository, all files and changes will be visible to anyone with access to the remote repository.
- `git fetch` is a command used to get files from the remote repository to the local repository but not into the working directory.
- `git merge` is a command used to get the files from the local repository into the working directory.
- `git pull` is command used to get files from the remote repository directly into the working directory. It is equivalent to a `git fetch` and a `git merge` .



#### Account

```shell
$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
```

```shell
$ git config --global user.name "YOUR_USERNAME" 
$ git config --global user.email "im_satoshi@musk.com"
$ git config --global --list # To check the info you just provided
```

#### Start

```shell
$ cd 
$ touch README.md
$ git init
$ git add . # Adds all 
$ git status # Lists all new or modified files to be committed
$ git commit -m "First commit"
```

View Commit History:
```shell
$ git log
```

See the Changes you made to your file
```shell
$ git diff # To show the files changes not yet staged
```

#### Uncommit

Uncommit Changes you just made to your Git Repo:

```shell
$ git reset HEAD~1 # Remove the most recent commit# Commit again!
```

#### Revert

Revert  back to the last committed version to the Git Repo:    checkout 主要用于切换branch
 if (stage has  file) {always from stage}  else {from last commit}

```shell
$ git checkout .    # Danger
$ git checkout -- <filename>
```

#### Add remote and Push

```shell
$ git remote add origin remote_repository_URL# sets the new remote
$ git remote -v# List the remote connections you have to other repositories.
$ git push -u origin master # pushes changes to origin
```

-u upstream与有几个远程库没有关系，它是分支与分支之间的流通道; 每个git branch可以有个对应的upstream,比如给local1和branch1两个分支建立关联，也就是说local1的upstream指向的是branch1。这样的好处就是在local1分支上执行git push（git pull同理）操作时不用附加其它参数

```shell
$ git add .
$ git status # Lists all new or modified files to be committed
$ git commit -m "Second commit"
$ git push -u origin master
```

#### Clone

```shell
$ git clone remote_repository_URL
```

#### Collaborating

make sure you’re working on the latest version of the git repo each time you start working, a git pull command is the way to go.

```shell
$ git pull origin master

$ git fetch
$ git merge
```

`git pull` **automatically merges the commits without letting you review them first**.

`git fetch`  keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use `git merge`.

#### More

`.gitignore` tells git which files (or patterns) it should ignore.





## Learn Git

https://www.codecademy.com/learn/learn-git

#### Workflow

![image-20191113143216690](/img/in-post/GIT.assets/image-20191113143216690.png)



1. A *Working Directory*: where you’ll be doing all the work: creating, editing, deleting and organizing files
2. A *Staging Area*: where you’ll list changes you make to the working directory
3. A *Repository*: where Git permanently stores those changes as different *versions* of the project



```shell
git init
git status
git add file1 file2 
git diff filename
git commit -m "msg"
git log
```

stuck in Git log, press `q` 



#### Backtrack

`git show`  For commits it shows the **log** message and textual **diff**. 

```shell
git show  #  see the default HEAD commit
```



`git checkout file`: **discard  changes** and restore the file,   将working中修改的file废弃,  unrecoverable
从 last commit repo里恢复文件, 并且从stage清空该文件

```shell
git checkout HEAD filename
```
恢复至git里最新的版本,  if (stage has  file) {always from stage}  else {from last commit}

```shell
git checkout -- filename # 在与branch名不冲突的情况下,可以省略 --
git checkout -- .   # git checkout .  这条命令最危险！会清除所有本地的修改
```



`git reset HEAD filename` : **unStage**, **unAdd**,   从stage里面清空,  防止不小心add了,   不影响working  



重设 HEAD

```shell
git reset commit_SHA  #HEAD is now set to commit_SHA
```



#### Branch

```shell
git branch  # which on
git branch new_branch
git checkout branch_name
```

```shell
git merge branch_name
```

fast forward :  fetch, no conflicts  merge

```shell
git branch -d branch_name  # del  合完的branch没啥用了可以删掉
-D # 明确删
```

```python
<<<<<<< HEAD
master version of line
=======
fencing version of line
>>>>>>> fencing
```



#### Teamwork

```shell
git clone remote_location directory_name
```

```shell
git remote -v
```



同步  `origin/master` 

```shell
git fetch
git merge origin/master
```
fetch 之后, orgin有了更新, 多了一个origin/master版本可以merge , clone的项目会有这个
如果手动remote add, fetch后,没有这个, 需要用 remotes/origin/master

```shell
git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
```



1. Fetch and merge changes from the remote
2. Create a branch to work on a new project feature
3. Develop the feature on your branch and commit your work
4. Fetch and merge from the remote again (in case new commits were made while you were working)
5. *Push* your branch up to the remote for review

```shell
git push origin your_branch_name
```

接受方会收到一个branch, checkout 过去可以看到push过来的东西







## Interactive Browser-Based Scenarios

https://www.katacoda.com/courses/git

#### Committing Files

```shell
git init
git status # working tree status
```

All files are "untracked" by Git until it's been told otherwise.

```shell
echo '*.tmp' > .gitignore
git add .gitignore
git commit -m "gitignore file"
```

#### Committing Changes

diff 是最短的距离,  working 与 stage

![Picture](https://coderwall-assets-0.s3.amazonaws.com/uploads/picture/file/32/Graphical_Git_Diff.png)



`git diff <commit>`   compare against an older version

`git diff filename` 指定文件

`git difftool`  打开第三方工具

`git diff --staged` ==  `git diff --cached`



`git mv` and `git rm`  可以直接同步到staging,  否则自己改名或者删文件需要再 track一下  



`git log`  see the history of the repository. 

`git show`  view the **changes** made in the HEAD commit  看具体改变内容
`git show <commit-hash>` to view older changes.



####  Working Remotely

`git remote` command with a friendly name and the remote location

`git clone`   location  automatically added as a remote with the name *origin*.  clone过来自动有origin

这里的origin 必须是公共仓库,  创建  git init --bare

手动添加origin

```shell
git remote add origin /s/remote-project/1
git push origin master
git pull origin master
```

还一个方式是clone过来

`git pull`  = fetch + merge, 
sync changes from a remote repository into your local version. automatically merge into the branch you're currently working on.

`git fetch` downloads the changes from the remote repository into a separate branch named *remotes/remote-name/remote-branch-name*. The branch can be accessed using `git checkout`.

`git fetch` is a great way to review the changes without affecting your current branch. 

```shell
git checkout remotes/origin/master
```

merge the fetched changes into master.

```
git merge remotes/<remote-name>/<remote-branch-name> master
```



`git branch -r`  list of all the remote branches 



#### Undoing Changes

 replace everything in the working directory to the last committed version.

```shell
git checkout .
```

back from the staging  to  working .

```shell
git reset HEAD .
```

git reset --hrard  = reset +  checkout  ,  removed  from  staging  and  working   back to  last commit. clear

```shell
git reset --hard HEAD
```

Undo commit  放弃上次提交,  revert

```shell
git revert HEAD --no-edit
```

如果还没push的话, 也可以用   git reset HEAD~1

多revert 几个

```shell
git revert HEAD...HEAD~2 --no-edit
badab1a Revert "444"
90c17f3 Revert "555"
cf27226 555
e51e257 444
6f17e92 333
4e90df1 222
6a51ae1 111
```

working文件内容变为333



```shell
 git log --oneline
```



#### Fixing Merge Conflicts

 `git fetch`   downloads  into a separate branch which can be checked out and merge. 

`git diff`   fetch后看看两边差异

'fast-forwarded' 

```shell
git merge remotes/origin/master
```

`git mergetool`



fetch后, 合并冲突, 可以直接checkout选其中一方, 或者手动合并; 然后add,commit

simplest way to fix a conflict is to pick  `git checkout --ours staging.txt` or `git checkout --theirs staging.txt`



If you want to revert in the middle of a merge  `git reset --hard HEAD` to go back to your previous state.

`git commit --no-edit` when you wish to use the default commit message.



pull,  If no conflicts exist then the merge will be completed and a new commit will be created to indicate the merge happening at that point in time.  

`git pull --no-edit origin master`  使用默认的merge msg

`git log --all --decorate --oneline`



```shell
$ git checkout experiment
$ git rebase master # experiment 放 master 后面, 然后再merge过去
```

**rebase** will unwind the changes you've made and **replay** the changes in the branch, applying your changes as if they happened all on the same branch. The result is a clean history and graph for the merge.

*Important* As `rebase` will replay the changes instead of merging, each commit will have a new hash id. 

**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行变基操作。**

如果把变基当成一种在推送之前清理提交历史的手段，而且仅仅变基那些尚未公开的提交对象，就没问题。

https://git-scm.com/book/en/v2/Git-Branching-Rebasing#The-Perils-of-Rebasing

This approach also applies when working with remote branches and can be applied when issuing a pull request using:

```
git pull --rebase
```

This will act as if you had done a pull request before each of your commits.





```undefined
git pull = git fetch + git merge FETCH_HEAD 

git pull --rebase =  git fetch + git rebase FETCH_HEAD 
```

现在我们有这样的两个分支,test和master，提交如下：

```bash
       D---E test
      /
 A---B---C---F--- master
```

在master执行git merge test,然后会得到如下结果：

```bash
       D--------E
      /          \
 A---B---C---F----G---   test, master
```

在master执行git rebase test，然后得到如下结果：

```bash
A---B---D---E---C‘---F‘---   test, master
```

merge操作会生成一个新的节点，之前的提交分开显示。
而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交



#### Experiments Using Branches

`git branch <new branch name> <starting branch>`

`git checkout <new branch name>`

`git checkout -b <new branch name> ` 	create and checkout

`git branch -va`  List **all** the branches with their last commit message 

```shell
$ git checkout master
$ git merge new_branch
```

`git push <remote_name> <branch_name>`

`git branch -d <branch_name>`



#### Finding Bugs

 compare what's changed between commits. 

```shell
$ git diff HEAD~2 HEAD
```

`git log --oneline`

`git log -p` 	output the commit information with the differences of what changed

`git log -p -n 2` displays HEAD and HEAD~1

date using *--since="2 weeks ago"* and _--until="1 day ago".

`git log --grep="Initial"`  all the commits which include the word "Initial" in their commit message.

commit history can become noisy due to use merge notification commits. To remove them provide the argument *-m* with git log.

`git bisect`  二分查找过去的commit哪个有问题

```shell
$ git bisect start
$ git bisect good one
$ git bisect bad last
# git 会将指针指向两个版本之间的那次提交
# 测试是不是还报错，如果报错，继续搜索，输入git bisect bad
# 如果测试正常了，输入git bisect good
# 直到找到引入错误的确切那次commit
# 修改此次提交中引入的问题，必要时候可以通过git show获得这次commit更多的信息（比如文件对比等）
$ git bisect reset 返回之前的版本，把错误作为一个补丁进行修改即可

```

git bisect也支持图形化界面搞git bisect visualize会运行gitk，让你更方便的选择commit。git bisect bad 和 git bisect good中的bad/good也可以用new/old取代



`git blame <file>` shows the revision and author who last modified each line of a file. 查看文件的每个部分是谁修改的

Running blame on a file will output who last touched each line.

```
git blame list.html
```

If we know the lines which we're concerned with then we can use the *-L* parameter to provide a range of lines to output.

```
git blame -L 6,8 list.html
```



#### Being Picky With Git

`git cherry-pick <hash-id|ref>`   merge individual commits  从其他分支挑些commit来merge

can refer across branches using the syntax _~#_. For example `new_branch~3` refers to the second to-last commit in the branch

遇到冲突 ,  either manually fixing the files or selecting *theirs* or *ours* via `git checkout`.

`git cherry-pick --abort`  放弃合并

```shell
git cherry-pick new_branch~1
git status
git diff
git checkout --theirs list2.html
git add list2.html
git cherry-pick --continue
```

`git cherry-pick --continue`   Similar to using *merge*, resolving a cherry-pick will result in a commit.



#### Re-writing History

`--interactive` 可以省略为  `-i`

```shell
git rebase --interactive --root
git log --oneline 
```

 `git commit --amend`    faster alternative to change the last commit message , 与最后一次commit 合并



`git rebase --interactive HEAD~8`   modify the previous 8 commits 

squash the commits  压缩commit, 留下第一个为base. 

![img](/img/in-post/GIT.assets/2147642-42195cacced56729.png)

也可以调换顺序

也可以拆分

```shell
git rebase -i sha-id
把相应的 commit pick 改为 edit
git reset HEAD~

git add file3.txt
git commit -m "File 3"
git add file4.txt
git commit -m "File 4"

git rebase --continue
```


